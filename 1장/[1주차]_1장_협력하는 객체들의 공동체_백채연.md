# 01 협력하는 객체들의 공동체

객체지향 프로그래밍 → 현실 속에 존재하는 사물을 최대한 유사하게 모방해 SW 내부로 옮겨오는 작업

- 객체 → 현실 세계에 존재하는 사물에 대한 추상화
- 객체와 대응되는 실세계 사물 발견할 확률 높지 않음

<br>

객체지향의 목표 → *새로운 세계 창조*

- 객체를 스스로 생각하고 결정하는 생명체에 비유: 캡슐화, 자율성
- 현실 세계 사람들이 암묵적인 약속과 명시된 계약을 바탕으로 협력하며 목표 달성: 메시지, 협력
- 실세계 사물 기반으로 SW 객체 식별하고 구현: **연결 완전성**

<br>

## 커피 공화국의 아침

음료 주문 과정 → **역할, 책임, 협력**이라는 세 가지 개념의 조화

커피 주문이라는 **협력**에 참여하는 이들은 맡은 바 **역할**과 **책임** 다 함

1. 손님, 캐셔, 바리스타 사이 암묵적인 협력 관계 존재
2. *주문하는* 손님, *주문 받는* 캐셔, *커피 제조하는* 바리스타라는 역할 존재
3. 주문한 커피를 제공하기 위해 자신이 맡은 바 책임 다 함

<br>

## 요청과 응답으로 구성된 협력

요청과 응답을 통한 협력 → 거대하고 복잡한 문제를 해결할 수 있는 공동체 형성

- 문제 해결에 필요한 지식을 알고 있거나 서비스 제공할 수 있는 사람에게 도움을 **요청**
    
    > 손님 - (커피를 주문하는 요청) → 캐시어 → (커피를 제조할 것을 요청) → 바리스타
    > 
- 요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스 제공, 즉 다른 사람의 요청에 **응답**
    
    > 손님 ← (커피 완성 응답) - 캐시어 ← (커피 완성 응답) → 바리스타
    > 

<br>

### **역할과 책임**

- 역할
    - 어떤 협력에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 임무
    - 의미적으로 책임이라는 개념 내포
- 협력을 위해 특정 역할 맡고 역할에, 적합한 책임 수행
    1. 여러 사람이 동일한 역할 수행
        - 손님 입장에서 어떤 캐셔가 주문을 받고, 어떤 바리스타가 커피를 제조하는지 상관 X
    2. 역할 == 대체 가능성
        - 동일 역할 수행 가능하다면 어떤 사람이 역할 맡아도 괜찮다
    3. 책임 수행하는 방법은 자율적으로 선택
        - 역할 수행하는 사람마다 서로 다른 방식으로 요청 처리
            - 카푸치노 크림 올리는 바리스타, 원두 더 맛있게 하는 바리스타 등
        - **다형성 (polymorphism)**
    4. 한 사람이 동시에 여러 역할 수행
        - 한 사람이 캐셔, 바리스타 역할 수행 가능

<br>

## 역할, 책임, 협력

일상 생활에서의 목표 → 사람들의 협력을 통해 달성되며, 목표는 더 작은 책임으로 분할되고 책임을 수행할 수 있는 적절한 역할을 가진 사람에 의해 수행

- 시스템
    - 역할과 책임을 수행하는 객체로 분할됨
- 시스템의 기능
    - 애플리케이션의 기능을 구현하기 위해 객체들이 협력
    - 객체 간 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현

<br>

**객체지향의 설계**

- 적절한 객체에게 적절한 책임을 할당하는 것에서 시작
    - 책임: 객체지향 설계의 품질을 결정하는 중요한 요소
- 역할은 유연하고 재사용 가능한 협력 관계 구축하는데 중요한 설계 요소
- 대체 가능 역할, 책임 → 다형성 연관

<br>

### 협력 속에 사는 객체

객체지향 애플리케이션의 아름다움 결정 → 협력

협력이 얼마나 조화를 이루는지 결정 → **객체**

<br>


**객체의 두 가지 덕목**

객체 → 상태(state)와 행동(behavior)을 함께 지닌 실체

스스로 판단하고 결정하는, 자율적인 존재로 남기 위해 필요한 행동과 상태 함께 지녀야 함

1. 객체는 충분히 ‘**협력적**’이어야 한다
    - 외부 도움 무시한 채 스스로 처리하려 하는 객체는 내부적인 복잡도에 의해 자멸
    - 다른 객체 명령에 복종하는 것 X → *요청에 응답하는 것*
2. 객체는 충분히 ‘**자율적**’이어야 한다
    - 공동의 목표를 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동
    - 객체의 자율성 → 객체의 내부와 외부 명확하게 구분
        - 객체 사적인 부분: 객체 스스로 관리, 외부 일체 간섭 X
        - 객체 외부 부분: 접근이 허락된 수단을 통해서만 객체와 의사소통
    - 다른 객체가 ‘무엇(what)’을 수행하는지 알 수 있지만, ‘어떻게(how)’ 수행하는지에 대해서 알 수 없음

<br>

### 협력과 메시지

메시지 → 객체 지향 세계에서 오직 한 가지 의사소통 수단

- 송신자(sender): 메시지를 전송하는 객체
- 수신자(receiver): 메시지를 수신하는 객체

<br>

### 메서드와 자율성

메서드 → 객체가 수신된 메시지를 처리하는 방법

- 클래스 안에 포함된 함수, 프로시저 통해 구현
- 절차적 언어와 구분되는 특징 *→ 메시지를 수신한 객체가 실행 시간에 메서드를 선택*
    - 절차적 언어
        
        프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정
        

메시지와 메서드의 분리 → 객체의 협력에 참여하는 객체들 간 자율성 증진 (**캡슐화**)

ex) 커피 제조 요청 (메시지), 커피 제조하는 구체적인 방법 (메서드)

- 커피 제조 요청한 캐셔는 커피 제조될 것이라 기대함
- 그러나 구체적인 방법에는 관여 X

<br>

### 객체를 지향하라

객체지향 세계에서 클래스(class) == 에스키모인들의 눈

- 클래스의 중요성 부풀려짐
    - 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합
- 객체지향 중심에 있어야할 객체로부터 멀어져 감

코드를 담는 클래스의 관점 → **메시지를 주고받는 객체의 관점으로 사고 중심 전환**

- 클래스는 협력에 참여하는 객체를 만드는데 필요한 구현 메커니즘
- 클래스의 구조와 메서드가 아닌 객체의 역할, 책임, 협력에 집중
